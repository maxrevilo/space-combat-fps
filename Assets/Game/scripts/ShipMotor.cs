using UnityEngine;using System.Collections;[RequireComponent(typeof(Transform))][RequireComponent (typeof(Rigidbody))]public class ShipMotor : MonoBehaviour {    // M/s    [SerializeField]    private float maxSpeed = 200;    // Degrees from horizontal plane.    [SerializeField]    private float maxPitchAngle = 90;    // Degrees from Horizontal plane.    [SerializeField]    private float minPitchAngle = -90;    // Deg/s. Degrees arround Y Axis per second.    [SerializeField]    private float maxTurnOverY = 60;    // 1 is maxSpeed 0 is none.    public float thrust;    // 1 is maxSpeed 0 is none.    public float turnAmount;    // 1 is maxSpeed 0 is none.    public void setThrust(float value)    {        thrust = value;    }    // 0 is no turn, 1 is max right turn -1 is the oposite.    public void setTurnAmount(float value)    {        turnAmount = value;    }    // 0 no pitch, -1 heading down, 1 heading up.    public void setPitchAngle(float value)    {        Vector3 angles = _transform.rotation.eulerAngles;        float targetAngle = minPitchAngle + (maxPitchAngle - minPitchAngle) * (value + 1)/2;        angles.x = targetAngle;        _transform.rotation = Quaternion.Euler(angles);    }    private Rigidbody _rigidBody;    private Transform _transform;    void Awake()    {        _transform = GetComponent<Transform>();        _rigidBody = GetComponent<Rigidbody>();    }    // Use this for initialization    void Start () {        Initialize();    }    void Initialize()    {        thrust = 0;    }		// Update is called once per frame	void Update () {		}    void FixedUpdate()    {        // Velocity        _rigidBody.velocity = _transform.forward * thrust * maxSpeed;        //Rotation        if(Mathf.Abs(turnAmount) > float.Epsilon)        {            float angleDiff = turnAmount * maxTurnOverY * Time.fixedDeltaTime;            Quaternion rotationDiff = Quaternion.AngleAxis(angleDiff, Vector3.up);            _transform.rotation = rotationDiff * _transform.rotation;        }    }}